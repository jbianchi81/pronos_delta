# -*- coding: utf-8 -*-

"""Prono_SanFernando.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fgX7obwikorAVqUiU-WF1SKAS98wYH6v
"""

# import psycopg2
import datetime
from datetime import timedelta, timezone
import pytz
import pandas as pd
# import numpy as np

import matplotlib
matplotlib.use('Agg')  # comentar para versiones más nuevas de matplotlib
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.dates import DateFormatter

from sklearn import datasets, linear_model
from sklearn.metrics import mean_squared_error, r2_score

import requests
import json
import argparse
import os
import locale

# set locale for date formatting
locale.setlocale(locale.LC_ALL,"es_AR.utf8")

local_timezone = pytz.timezone('America/Argentina/Buenos_Aires')

script_dir = os.path.dirname(os.path.abspath(__file__))
config_path = os.path.join(script_dir,"config.json")
with open(config_path) as f:
	config = json.load(f)

from a5client import Crud
client = Crud(config["api"]["url"], config["api"]["token"])

# '''Conecta con BBDD'''
# try:
#    conn_string = "dbname='%s' user='%s' host='%s' port='%d'" % (config["database"]["dbname"], config["database"]["user"], config["database"]["host"], config["database"]["port"])
#    conn = psycopg2.connect(conn_string)
#    cur = conn.cursor()
# except:
#    print( "No se ha podido establecer conexion.")
#    exit(1)

def readAdjustAndPlotProno(plots_auxiliares = False, forecast_horizon : int = 4, warmup_period : int = 1):
    ahora = datetime.datetime.now()
    DaysMod = 15   
    f_fin = ahora
    f_inicio = (f_fin - timedelta(days=DaysMod)).replace(hour=0, minute=0, second=0)

    unid_margen_derecha = 52 # 85
    series_id_margen_derecha = 52

    # consulta a5
    # OBSERVADOS
    serie_sfer_obs = client.readSerie(series_id_margen_derecha, f_inicio, f_fin, "puntual")
    # PRONOSTICADOS
    serie_sfer_prono = client.readSeriePronoConcat(707, 6066, "median", f_inicio, f_fin + timedelta(days=forecast_horizon))
    # fecha emision
    forecast_date = datetime.datetime.fromisoformat(serie_sfer_prono['forecast_date'].replace("Z", "")).replace(tzinfo=timezone.utc)

    df_sfer_obs = pd.DataFrame(serie_sfer_obs["observaciones"])[["timestart","valor"]].rename(columns={"timestart":"fecha","valor":"obs"})
    df_sfer_obs["fecha"] = pd.to_datetime(df_sfer_obs['fecha'])
    df_sfer_obs.set_index("fecha",inplace=True)
    df_sfer_obs.index = df_sfer_obs.index.tz_convert('America/Argentina/Buenos_Aires')

    df_sfer_prono = pd.DataFrame(serie_sfer_prono["pronosticos"])[["timestart","valor"]].rename(columns={"timestart":"fecha","valor":"sim"})
    df_sfer_prono["fecha"] = pd.to_datetime(df_sfer_prono['fecha'])
    df_sfer_prono.set_index("fecha",inplace=True)
    df_sfer_prono.index = df_sfer_prono.index.tz_convert('America/Argentina/Buenos_Aires')
    
    indexUnico = pd.date_range(start=df_sfer_prono.index.min(), end=df_sfer_prono.index.max(), freq='15min')	    #Fechas desde f_inicio a f_fin con un paso de 5 minutos
    df_base = pd.DataFrame(index = indexUnico)								#Crea el Df con indexUnico
    df_base.index.rename('fecha', inplace=True)							    #Cambia nombre incide por Fecha
    df_base.index = df_base.index.round("15min")

    df_base = df_base.join(df_sfer_prono[['sim']], how = 'left')
    df_base = df_base.join(df_sfer_obs[['obs']], how = 'left')
    df_base['obs'] = df_base['obs'].interpolate(limit=2)

    df_base = df_base.dropna()

    if plots_auxiliares:
        fig = plt.figure(figsize=(15, 8))
        ax = fig.add_subplot(1, 1, 1)
        ax.plot(df_base.index, df_base['obs'],'o',label='h_obs',linewidth=1)
        ax.plot(df_base.index, df_base['obs'],'-',color='k',linewidth=1)    
        ax.plot(df_base.index, df_base['sim'],'-',label='h_sim: solo Suma',linewidth=2)
        # ax.plot(df_base.index, df_base['h_ast_ign'],'-',label='h_ast_ign',linewidth=0.8)
        # ax.plot(df_base.index, df_base['h_met'],'-',label='h_met',linewidth=0.8)
        plt.grid(True, which='both', color='0.75', linestyle='-.',linewidth=0.7)
        plt.tick_params(axis='both', labelsize=16)
        plt.xlabel('Fecha', size=18)
        plt.ylabel('Nivel [m]', size=18)
        plt.legend(prop={'size':16},loc=2,ncol=2 )
        plt.show()
        plt.close()

    ## Modelo
    train = df_base[:].copy()
    var_obj = 'obs'
    covariav = ['sim']
    lr = linear_model.LinearRegression()
    X_train = train[covariav]
    Y_train = train[var_obj]
    lr.fit(X_train,Y_train)

    # Create the test features dataset (X_test) which will be used to make the predictions.
    X_test = train[covariav].values 
    # The labels of the model
    Y_test = train[var_obj].values
    Y_predictions = lr.predict(X_test)
    train['Y_predictions'] = Y_predictions

    # The coefficients
    print('Coefficients: \n', lr.coef_)
    # The mean squared error
    mse = mean_squared_error(Y_test, Y_predictions)
    print('Mean squared error: %.5f' % mse)
    # The coefficient of determination: 1 is perfect prediction
    coefDet = r2_score(Y_test, Y_predictions)
    print('r2_score: %.5f' % coefDet)
    train['Error_pred'] =  train['Y_predictions']  - train[var_obj]


    if plots_auxiliares:
        fig = plt.figure(figsize=(15, 8))
        ax = fig.add_subplot(1, 1, 1)
        # Plot outputs
        plt.scatter(Y_predictions, Y_test,  label='A01')
        plt.xlabel('sim', size=12)
        plt.ylabel('obs', size=12)
        plt.legend(prop={'size':16},loc=2,ncol=2 )
        plt.show()
        fig = plt.figure(figsize=(15, 8))
        ax = fig.add_subplot(1, 1, 1)
        # Plot outputs
        plt.scatter(train['Y_predictions'], train['Error_pred'], label='Error')
        plt.xlabel('H Sim', size=12)
        plt.ylabel('Error', size=12)
        plt.legend(prop={'size':16},loc=2,ncol=2 )
        plt.show()


    quant_Err = train['Error_pred'].quantile([0.05,.25, .75,0.95])

    # Plot final
    DaysMod = 1
    f_fin = ahora
    f_inicio = (f_fin - timedelta(days=DaysMod)).replace(hour=0, minute=0, second=0)
    f_fin = (f_fin + timedelta(days=5))

    # Pronostico
    covariav = ['sim']
    prediccion = lr.predict(df_sfer_prono[covariav].values)
    df_sfer_prono['adjusted'] = prediccion

    df_sfer_prono['e_pred_05'] = df_sfer_prono['adjusted'] + quant_Err[0.05]
    df_sfer_prono['e_pred_25'] = df_sfer_prono['adjusted'] + quant_Err[0.25]
    df_sfer_prono['e_pred_75'] = df_sfer_prono['adjusted'] + quant_Err[0.75]
    df_sfer_prono['e_pred_95'] = df_sfer_prono['adjusted'] + quant_Err[0.95]

    # PLOT
    fig = plt.figure(figsize=(16, 12))
    ax = fig.add_subplot(1, 1, 1)

    df_plot = df_sfer_prono[(df_sfer_prono.index <= forecast_date + timedelta(days=forecast_horizon)) & (df_sfer_prono.index >= forecast_date - timedelta(days=warmup_period))] # recorta warmup y horizonte de pronóstico

    ax.plot(df_plot.index, df_plot['adjusted'], '-',color='b',label='Nivel Pronosticado (*)',linewidth=3)

    ax.plot(df_sfer_obs.index, df_sfer_obs['obs'],'o',color='k',label='Nivel Observado',linewidth=3)
    ax.plot(df_sfer_obs.index, df_sfer_obs['obs'],'-',color='k',linewidth=1,label="_altura")


    ax.plot(df_plot.index, df_plot['e_pred_05'],'-',color='k',linewidth=0.5,alpha=0.75,label="_nolegend_")
    ax.plot(df_plot.index, df_plot['e_pred_95'],'-',color='k',linewidth=0.5,alpha=0.75,label="_nolegend_")
    ax.fill_between(df_plot.index,df_plot['e_pred_05'], df_plot['e_pred_95'],alpha=0.1,label='Banda de error')

    # Lineas: 1 , 1.5 y 2 mts
    xmin=df_plot.index.min()
    xmax=df_plot.index.max()

    plt.hlines(3.5, xmin, xmax, colors='r', linestyles='-.', label='Evacuación',linewidth=1.5)
    plt.hlines(3, xmin, xmax, colors='y', linestyles='-.', label='Alerta',linewidth=1.5)

    plt.axvline(x=forecast_date,color="black", linestyle="--",linewidth=2)#,label='Fecha de emisión')

    bbox = dict(boxstyle="round", fc="0.7")
    arrowprops = dict(
        arrowstyle="->",
        connectionstyle="angle,angleA=0,angleB=90,rad=10")
    offset = 10


    xdisplay = ahora + timedelta(days=0.6)
    ax.annotate('Pronóstico',
        xy=(xdisplay, -0.8), xytext=(-8*offset, -offset), textcoords='offset points',
        bbox=bbox, fontsize=18)#arrowprops=arrowprops

    xdisplay = ahora - timedelta(days=1.8)
    ax.annotate('Días pasados',
        xy=(xdisplay, -0.8), xytext=(-8*offset, -offset), textcoords='offset points',
        bbox=bbox, fontsize=18)


    ax.annotate(
        'Fecha de emisión',
        xy=(forecast_date - timedelta(days=0.01), -0.35),fontsize=15, xytext=(forecast_date + timedelta(days=0.45), -0.30), arrowprops=dict(facecolor='black',shrink=0.05)
    )


    nombre_estacion = 'San Fernando'
    cero = -0.53
    ylim=(-1,4)


    fig.subplots_adjust(bottom=0.205,right=0.7)
    plt.figtext(0,0,'          (*) Esta previsión surge de aplicar el Modelo Matemático del Delta del Programa de Hidráulica Computacional (PHC) de la Subgerencia \n          del Laboratorio de Hidráulica (SLH) del Instituto Nacional del Agua (INA), forzado por el caudal pronosticado del río Paraná de acuerdo \n          al Sistema de Información y Alerta Hidrológico (SIyAH-INA) y por el nivel del Río de la Plata en el arco San Fernando - Nueva Palmira \n          pronosticado por el Servicio de Hidrografía Naval (SHN) y el Servicio Meteorológico Nacional (SMN). \n          (**) El cero de la escala de ' + nombre_estacion + ' corresponde a ' + str(cero+0.53) +' mMOP / '+ str(cero) +' mIGN \n',fontsize=12,ha="left")
    if ylim:
        ax.set_ylim(ylim[0],ylim[1])

    ax.set_xlim(xmin,xmax)
    ax.tick_params(labeltop=False, labelright=True)

    plt.grid(True, which='both', color='0.75', linestyle='-.',linewidth=0.5)
    plt.tick_params(axis='both', labelsize=16)
    plt.xlabel('Fecha', size=16)
    plt.ylabel('Nivel [m] Referido al cero local (**)', size=20)
    plt.legend(prop={'size':18},loc=2,ncol=2 )
    plt.title('Previsión de niveles a corto plazo en ' + nombre_estacion,fontsize=20)

    local_ahora = local_timezone.localize(ahora)

    #### TABLA
    h_resumen = [0,6,12,18]
    df_prono = df_plot[df_plot.index > local_ahora ].copy()
    # df_prono.set_index(df_prono['fecha'], inplace=True)
    df_prono['Hora'] = df_prono.index.hour
    df_prono['Dia'] = df_prono.index.day
    df_prono = df_prono[df_prono['Hora'].isin(h_resumen)].copy()

    #print(df_prono)
    df_prono['Y_predic'] = df_prono['adjusted'].round(2)
    df_prono['Hora'] = df_prono['Hora'].astype(str)
    df_prono['Hora'] = df_prono['Hora'].replace('0', '00')
    df_prono['Hora'] = df_prono['Hora'].replace('6', '06')
    df_prono['Dia'] = df_prono['Dia'].astype(str)
    df_prono['Fechap'] = df_prono['Dia']+' '+df_prono['Hora']+'hrs'

    df_prono = df_prono[['Fechap','Y_predic',]]
    #print(df_prono)
    cell_text = []

    for row in range(len(df_prono)):
        cell_text.append(df_prono.iloc[row])
        #print(cell_text)

    columns = ('Fecha','Nivel',)
    table = plt.table(cellText=cell_text,
                    colLabels=columns,
                    bbox = (1.08, 0, 0.2, 0.5))
    table.set_fontsize(12)
    #table.scale(2.5, 2.5)  # may help


    date_form = DateFormatter("%Hhrs \n %d-%b", "America/Argentina/Buenos_Aires")
    ax.xaxis.set_major_formatter(date_form)
    ax.xaxis.set_minor_locator(mdates.HourLocator((0,6,12,18,), tz="America/Argentina/Buenos_Aires")) #3,9,15,21,)))


    ## FRANJAS VERTICALES
    df_plot['horas'] =  df_plot.index.hour
    list0hrs = df_plot[df_plot['horas']==0].index.tolist()
    ax.axvspan(list0hrs[0], list0hrs[1], alpha=0.1, color='grey')
    i = 2
    while i <= len(list0hrs) - 1:
        if  i + 1 <= len(list0hrs) - 1:
            ax.axvspan(list0hrs[i], list0hrs[i + 1], alpha=0.1, color='grey')
        else:
            ax.axvspan(list0hrs[i], df_plot.index.max(), alpha=0.1, color='grey')
        i = i + 2
    # if len(list0hrs) >= 4:
    #     ax.axvspan(list0hrs[2], list0hrs[3], alpha=0.1, color='grey')
    # if len(list0hrs) >= 5:
    #     if len(list0hrs) >= 6:
    #         ax.axvspan(list0hrs[4], list0hrs[5], alpha=0.1, color='grey')
    #     else:
    #         ax.axvspan(list0hrs[4], df_plot.index.max(), alpha=0.1, color='grey')
    # if len(list0hrs) >= 7:
    #     if len(list0hrs) >= 8:
    #         ax.axvspan(list0hrs[6], list0hrs[7], alpha=0.1, color='grey')
    #     else:
    #         ax.axvspan(list0hrs[6], df_plot.index.max(), alpha=0.1, color='grey')


    #plt.show()

    script_dir = os.path.dirname(os.path.abspath(__file__))
    png_path = os.path.join(script_dir, 'productos', 'Prono_SanFernando.png')
    plt.savefig(png_path, format='png')# , dpi=200, facecolor='w', edgecolor='w',bbox_inches = 'tight', pad_inches = 0
    plt.close()

    return df_sfer_prono, forecast_date

def dfToA5(df_sfer_prono, forecast_date) -> dict:
    # df para UPSERT
    df_para_upsert = df_sfer_prono[['adjusted']].reset_index().rename(columns = {'fecha':'timestart', 'adjusted':'valor'},inplace = False)
    df_para_upsert['qualifier'] = 'main'
    df_para_upsert = pd.concat([df_para_upsert, df_sfer_prono[['e_pred_05']].reset_index().rename(columns = {'fecha':'timestart', 'e_pred_05': 'valor'})], ignore_index=True)
    df_para_upsert.fillna({'qualifier':'p05'},inplace=True)
    df_para_upsert = pd.concat([df_para_upsert, df_sfer_prono[['e_pred_25']].reset_index().rename(columns = {'fecha':'timestart', 'e_pred_25': 'valor'})], ignore_index=True)
    df_para_upsert.fillna({'qualifier':'p25'},inplace=True)
    df_para_upsert = pd.concat([df_para_upsert, df_sfer_prono[['e_pred_75']].reset_index().rename(columns = {'fecha':'timestart', 'e_pred_75': 'valor'})], ignore_index=True)
    df_para_upsert.fillna({'qualifier':'p75'},inplace=True)
    df_para_upsert = pd.concat([df_para_upsert, df_sfer_prono[['e_pred_95']].reset_index().rename(columns = {'fecha':'timestart', 'e_pred_95': 'valor'})], ignore_index=True)
    df_para_upsert.fillna({'qualifier':'p95'},inplace=True)
    df_para_upsert['timeend'] = df_para_upsert['timestart']  # .map(lambda a : a.isoformat())
    # ~ df_para_upsert['timestart'] = df_para_upsert['timestart'].map(lambda a : a.isoformat())
    # ~ print(df_para_upsert)
    return {'forecast_date': forecast_date.isoformat(),
                'series': [
                    {
                        'series_table': 'series',
                        'series_id': 26202,
                        'pronosticos': json.loads(df_para_upsert.to_json(orient='records',date_format='iso'))
                    }
                ]}
    # ~ print(para_upsert)

    # UPSERT Simulado

def uploadProno(data,cal_id,responseOutputFile):
    response = requests.post(
        config["api"]["url"] + '/sim/calibrados/' + str(cal_id) + '/corridas',
        data=json.dumps(data),
        headers={'Authorization': 'Bearer ' + config["api"]["token"], 'Content-type': 'application/json'},
    )
    print("prono upload, response code: " + str(response.status_code))
    print("prono upload, reason: " + response.reason)
    if(response.status_code == 200):
        if(responseOutputFile):
            outresponse = open(responseOutputFile,"w")
            outresponse.write(json.dumps(response.json()))
            outresponse.close()

def main():
    parser = argparse.ArgumentParser(description="Ajusta prono en boca del Luján con obs en San Fernando, genera plot y guarda ajuste en DB")
    parser.add_argument('-u', '--upload', action='store_true', help='Upload to database')
    parser.add_argument('-o', '--output', required=False, help='Save result into file', default="productos/prono_sanFernando.json")
    args = parser.parse_args()
    
    df_sfer_prono, forecast_date = readAdjustAndPlotProno()
    para_upsert = dfToA5(df_sfer_prono, forecast_date)

    if args.upload:
        uploadProno(para_upsert,432,args.output)
    else:
        json.dump(para_upsert, open(args.output,"w",encoding="utf-8"))


if __name__ == "__main__":
    main()



